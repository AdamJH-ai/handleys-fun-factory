<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Controller</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <style>
        /* ==========================================================================
        1. THEME & GLOBAL SETUP (CONTROLLER)
        ========================================================================== */

        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Oswald:wght@500;700&display=swap');

        :root {
            /* This is the same theme palette from your main screen for consistency */
            --bg-primary: #222831;
            --bg-secondary: #393E46;
            --accent-gold: #FFD700;
            --accent-blue: #00ADB5;
            --text-primary: #EEEEEE;
            --text-secondary: #AAAAAA;
            --color-success: #2ecc71;
            --color-waiting: #7f8c8d;
            --color-danger: #e74c3c;
            --font-display: 'Oswald', sans-serif;
            --font-body: 'Montserrat', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--bg-primary); /* Dark background */
            color: var(--text-primary);
            padding: 15px;
        }

        .container {
            max-width: 420px;
            margin: auto;
            background-color: var(--bg-secondary); /* Dark container card */
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        /* ==========================================================================
        2. TYPOGRAPHY & FORMS (CONTROLLER)
        ========================================================================== */

        h1, h4 {
            font-family: var(--font-display);
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        h1 { font-size: 1.5em; margin-bottom: 20px; }
        h4 { font-size: 1em; color: var(--text-secondary); margin-bottom: 8px; }

        label {
            font-family: var(--font-display);
            display: block;
            margin-bottom: 10px;
            font-size: 1.2em;
            color: var(--text-primary);
        }

        input[type="text"], input[type="number"] {
            width: 90%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid var(--text-secondary);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 1.2em;
            text-align: center;
        }
        input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* ==========================================================================
        3. BUTTONS (CONTROLLER)
        ========================================================================== */

        button {
            display: block;
            width: 100%;
            padding: 15px;
            font-family: var(--font-display);
            font-size: 1.3em;
            font-weight: 700;
            text-transform: uppercase;
            background-color: var(--accent-blue);
            color: var(--text-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.1s ease;
        }
        button:not(:disabled):active {
            transform: scale(0.98); /* Give a nice press effect */
        }
        button:disabled {
            background-color: var(--color-waiting);
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Special case for Submit buttons, make them green */
        #submitGuessButton, #submitOrderButton, #submitPairsButton {
            background-color: var(--color-success);
        }

        /* ==========================================================================
        4. GAME-SPECIFIC COMPONENTS (CONTROLLER)
        ========================================================================== */

        /* --- Status Message --- */
        #status-message {
            margin-top: 20px;
            font-weight: bold;
            color: var(--accent-gold);
            min-height: 2em;
            font-size: 1.1em;
        }
        
        /* --- WDDI: Which Didn't Do It --- */
        #wddi-options-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 10px;
        }
        #wddi-options-area button {
            width: 100%; /* Grid handles width */
            margin: 0; /* Grid handles spacing */
            font-size: 1.1em; /* Slightly smaller for more text */
            padding: 15px 5px;
            background-color: var(--accent-blue);
        }

        /* --- OU: Order Up --- */
        #ou-items-list {
            list-style-type: none;
            margin-top: 15px;
        }
        #ou-items-list li {
            background-color: var(--accent-blue);
            color: var(--text-primary);
            padding: 15px 10px;
            margin-bottom: 10px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: 700;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #ou-items-list li.sortable-ghost { /* Dragging ghost */
            opacity: 0.4;
            background: var(--bg-primary);
            border: 2px dashed var(--accent-blue);
        }
        #ou-items-list li.sortable-chosen { /* The item you're holding */
            cursor: grabbing;
            transform: scale(1.05);
        }

        /* --- QP: Quick Pairs --- */
        .qp-lists-container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 15px;
        }
        .qp-list-column { width: 48%; }
        .qp-item-list {
            min-height: 120px;
            list-style-type: none; /* <<< ADD THIS LINE to remove bullets */
            padding: 0;            /* <<< ADD THIS LINE to remove default indent */
        }
        .qp-item-list li {
            background-color: transparent;
            color: var(--text-primary);
            border: 2px solid var(--accent-blue);
            padding: 10px 8px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
        }
        /* QP States */
        .qp-item-list li.qp-selected {
            background-color: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
            font-weight: 700;
            transform: scale(1.05);
        }
        .qp-item-list li.qp-paired {
            background-color: var(--color-success);
            color: var(--bg-primary);
            border-color: var(--color-success);
            cursor: not-allowed;
            opacity: 0.7;
        }
        #qp-formed-pairs-display {
            margin-top: 10px;
            min-height: 3em;
        }
        #qp-formed-pairs-display .formed-pair {
            display: inline-block;
            background-color: var(--bg-primary);
            color: var(--color-success);
            border: 1px solid var(--color-success);
            padding: 4px 8px;
            margin: 3px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        /* True or False States */
        #true-or-false-area {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Two equal columns */
            grid-gap: 15px;
            margin-top: 20px;
        }
        #true-or-false-area button {
            width: 100%;
            margin: 0;
            padding: 25px 10px; /* Make them nice and tall */
        }
        #true-button { background-color: var(--color-success); }
        #false-button { background-color: var(--color-danger); }

        /* --- TTP: Tap The Pic --- */
        #tap-the-pic-area {
            display: grid;
            /* This creates a flexible grid that will wrap nicely */
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            grid-gap: 10px;
            margin-top: 20px;
            max-width: 300px; /* Limit width to keep it keypad-like */
            margin-left: auto;
            margin-right: auto;
        }
        #tap-the-pic-area button {
            width: 100%;
            margin: 0;
            padding: 20px 10px;
            font-size: 1.5em; /* Big, easy-to-read numbers */
        }

        /* --- TTT: The Top Three --- */
        #top-three-options-list {
            list-style-type: none;
            padding: 0;
            margin: 15px 0;
        }
        #top-three-options-list li {
            background-color: transparent;
            color: var(--text-primary);
            border: 2px solid var(--accent-blue);
            padding: 12px 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.2s ease;
        }
        #top-three-options-list li.selected {
            background-color: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
            font-weight: 700;
        }
        #submitTopThreeButton {
            background-color: var(--color-success);
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Name Entry Area -->
        <div id="name-entry-area">
            <h1>Enter Your Name</h1>
            <label for="nameInput">Name:</label>
            <input type="text" id="nameInput" maxlength="15" placeholder="Your Name">
            <button id="joinButton">Join Game</button>
        </div>

        <!-- Guessing Area (Hidden Initially) -->
        <div id="guessing-area" class="hidden">
            <label id="guess-label">Prompt:</label>
            <!-- Input for GTA/GTY -->
            <input type="number" id="guessInput" placeholder="Enter number..." class="hidden">
            <button id="submitGuessButton" class="hidden" disabled>Submit Guess</button>
            <!-- Area for WDDI buttons -->
            <div id="wddi-options-area" class="hidden"></div>
            <!-- Area for Order Up! list -->
            <div id="ou-items-list-container" class="hidden">
                <ul id="ou-items-list">
                    <!-- List items will be dynamically added here by JavaScript -->
                </ul>
                <button id="submitOrderButton" class="hidden" disabled>Submit Order</button>
            </div>
            <!-- Area for Quick Pairs -->
            <div id="qp-pairing-area" class="hidden">
                <div class="qp-lists-container">
                    <div class="qp-list-column">
                        <h4>List A</h4>
                        <ul id="qp-list-a" class="qp-item-list">
                            <!-- Items for list A will be added here -->
                        </ul>
                    </div>
                    <div class="qp-list-column">
                        <h4>List B</h4>
                        <ul id="qp-list-b" class="qp-item-list">
                            <!-- Items for list B will be added here -->
                        </ul>
                    </div>
                </div>
                <div id="qp-formed-pairs-display" style="margin-top:10px; min-height: 3em;">
                    <!-- Visually show formed pairs here if desired -->
                </div>
                <button id="submitPairsButton" class="hidden" disabled>Submit Pairs</button>
            </div>
            <!-- Area for True or False buttons -->
            <div id="true-or-false-area" class="hidden">
                <button id="true-button" data-answer="true">True</button>
                <button id="false-button" data-answer="false">False</button>
            </div>    

            <!-- Area for Tap The Pic keypad -->
            <div id="tap-the-pic-area" class="hidden">
                <!-- Buttons will be dynamically generated here by JavaScript -->
            </div>

            <!-- Area for Tap The Pic keypad -->
            <div id="tap-the-pic-area" class="hidden">...</div>

            <!-- NEW: Area for The Top Three options -->
            <div id="top-three-area" class="hidden">
                <ul id="top-three-options-list">
                    <!-- Tappable list items will be generated here by JavaScript -->
                </ul>
                <button id="submitTopThreeButton" disabled>Submit</button>
            </div>
        </div>

        <!-- Status Message Area -->
        <div id="status-message">Connecting...</div>
    </div>

    <script>
        console.log("Player HTML Script Started.");

        // --- Element Refs (obtained in DOMContentLoaded) ---
        let nameEntryArea, nameInput, joinButton, guessingArea, guessLabel, guessInput;
        let submitGuessButton, statusMessage, wddiOptionsArea;
        let ouItemsListContainer, ouItemsList, submitOrderButton;
        let currentClientRoundType = null;
        let sortableInstance = null;
        let trueOrFalseArea, trueButton, falseButton;
        let tapThePicArea;
        let topThreeArea, topThreeOptionsList, submitTopThreeButton;

        // Variables for Quick Pairs logic
        let qpSelectedFromListA = null; // Stores the text of the item selected from list A
        let qpSelectedFromListB = null; // Stores the text of the item selected from list B (not strictly needed if A always first)
        let qpFormedPairs = [];        // Stores the pairs made by the player, e.g., [["France", "Paris"], ...]
        let qpStartTime = 0;           // To record when the player starts making pairs for timing
        const QP_NUM_PAIRS_TO_MAKE = 3; // Default, will be updated by server if different

        const serverIp = window.location.hostname;
        console.log(`Connecting to server: http://${serverIp}:5000`);
        const socket = io(`http://${serverIp}:5000`);

        // --- Helper Functions ---
        function showArea(areaToShowId) {
             // Add detailed logging inside showArea
             console.log(`Player: Attempting to show area ${areaToShowId}`);
             [nameEntryArea, guessingArea].forEach(area => {
                 if (!area) {
                     console.error(`  -> ERROR: Area variable is null/undefined in showArea loop! Cannot process ID: ${area ? area.id : 'N/A'}`);
                     return;
                 }
                 const areaId = area.id;
                 console.log(`  -> Checking area: ${areaId}`);
                 const hadHidden = area.classList.contains('hidden');

                 if (areaId === areaToShowId) {
                     area.classList.remove('hidden');
                     console.log(`  -> Should Show ${areaId}. Was hidden? ${hadHidden}. Now hidden? ${area.classList.contains('hidden')}.`);
                 } else {
                     area.classList.add('hidden');
                     console.log(`  -> Should Hide ${areaId}. Was hidden? ${hadHidden}. Now hidden? ${area.classList.contains('hidden')}.`);
                 }
             });
             console.log(`Player: Finished showArea attempt for ${areaToShowId}`);
         }

        function configureInputArea(roundType) {
            // Your existing check for element presence (now includes ou AND qp elements)
            if (!guessInput || !submitGuessButton || !wddiOptionsArea || 
                !ouItemsListContainer || !submitOrderButton || !ouItemsList ||
                !qpPairingArea || !submitPairsButton || !qpListA || !qpListB || !qpFormedPairsDisplay) {
                console.error("ERROR: Input configuration failed - one or more elements missing.");
                return;
            }
            console.log("Player: Configuring input for type:", roundType);

            // --- Start by hiding/resetting elements that might have been used by other rounds ---

            // Hide/reset Order Up elements if not 'ou' round
            if (roundType !== 'ou') {
                ouItemsListContainer.classList.add('hidden');
                submitOrderButton.classList.add('hidden');
                ouItemsList.innerHTML = ''; // Clear previous OU list items
                if (sortableInstance) { 
                    sortableInstance.destroy();
                    sortableInstance = null;
                    // console.log("   Destroyed previous SortableJS instance."); // Keep if useful
                }
            }

            // Hide/reset WDDI options if not 'wddi' round
            if (roundType !== 'wddi') {
                wddiOptionsArea.classList.add('hidden');
                wddiOptionsArea.innerHTML = ''; // Clear WDDI buttons
            }

            // Hide/reset GTA/GTY input if not 'gta' or 'gty' round
            if (roundType !== 'gta' && roundType !== 'gty') {
                guessInput.classList.add('hidden');
                submitGuessButton.classList.add('hidden');
            }

            // Hide/reset Quick Pairs elements if not 'qp' round
            if (roundType !== 'qp') {
                qpPairingArea.classList.add('hidden');
                submitPairsButton.classList.add('hidden');
                qpListA.innerHTML = ''; // Clear QP lists
                qpListB.innerHTML = '';
                qpFormedPairsDisplay.innerHTML = '';
                qpSelectedFromListA = null; // Reset QP selection state
                qpFormedPairs = [];
            }

            // Hide/reset True False if not 'tf' round
            if (roundType !== 'true_or_false') {
                trueOrFalseArea.classList.add('hidden');
            }

            // Hide/reset ttp if not 'ttp' round
            if (roundType !== 'tap_the_pic') {
                tapThePicArea.classList.add('hidden');
                tapThePicArea.innerHTML = ''; // Clear old buttons
            }

            // Hide/reset ttt if not 'ttt' round
            if (roundType !== 'the_top_three') {
                topThreeArea.classList.add('hidden');
                topThreeOptionsList.innerHTML = '';
            }

            // --- Now, selectively show/enable elements based on roundType ---
            if (roundType === 'gta' || roundType === 'gty') {
                console.log("   Configuring for GTA/GTY");
                guessInput.classList.remove('hidden');
                submitGuessButton.classList.remove('hidden');
                submitGuessButton.disabled = true;
                guessInput.disabled = true;
                guessInput.value = '';
            } else if (roundType === 'wddi') {
                console.log("   Configuring for WDDI");
                wddiOptionsArea.classList.remove('hidden');
                // WDDI buttons are added by its specific prompt handler
            } else if (roundType === 'ou') { // Order Up!
                console.log("   Configuring for Order Up!");
                ouItemsListContainer.classList.remove('hidden');
                submitOrderButton.classList.remove('hidden');
                submitOrderButton.disabled = true;
                // OU List items are added by its specific prompt handler
            } else if (roundType === 'qp') { // Quick Pairs!
                console.log("   Configuring for Quick Pairs!");
                qpPairingArea.classList.remove('hidden');
                submitPairsButton.classList.remove('hidden');
                submitPairsButton.disabled = true; // Will be enabled when appropriate
                // QP List items are added by its specific prompt handler
            } else if (roundType === 'true_or_false') {
                console.log("   Configuring for True or False");
                guessingArea.classList.remove('hidden'); // Also ensure the parent is visible
                trueOrFalseArea.classList.remove('hidden');
                // The prompt handler will enable/disable buttons
            } else if (roundType === 'tap_the_pic') {
                console.log("   Configuring for Tap The Pic");
                tapThePicArea.classList.remove('hidden');
            }
            else if (roundType === 'the_top_three') {
                console.log("   Configuring for The Top Three");
                topThreeArea.classList.remove('hidden');
                submitTopThreeButton.disabled = true; // Start with submit disabled
            }
            else { // Waiting, round over, or unknown state
                console.log("   Configuring for Waiting/Unknown state (all specific inputs should be hidden)");
                // All specific inputs are already hidden by the default hiding logic at the top of this function.
            }
        }

        // --- Socket Event Listeners ---
        socket.on('connect', () => {
            console.log('Player Connected! Socket ID:', socket.id);
            if (statusMessage) statusMessage.textContent = 'Connected! Enter name.';
            showArea('name-entry-area'); // Show name entry on connect
            if (joinButton) joinButton.disabled = false;
            configureInputArea(null); // Ensure all guess inputs hidden
            currentClientRoundType = null;
        });

        socket.on('disconnect', () => {
            console.log('Player Disconnected.');
            if (statusMessage) statusMessage.textContent = 'Disconnected! Reconnect?'; // Changed message slightly
            showArea('name-entry-area'); // Revert to name entry
            if (submitGuessButton) submitGuessButton.disabled = true;
            if (joinButton) joinButton.disabled = true; // Disable join until reconnected
            currentClientRoundType = null;
        });

        socket.on('message', (data) => {
            console.log('Player Server Message:', data.data);
            if (statusMessage) statusMessage.textContent = data.data;
        });

        // --- GTA Listeners ---
        socket.on('gta_player_prompt', (data) => {
            console.log('--- Event: gta_player_prompt received ---', data);
            currentClientRoundType = 'gta'; configureInputArea('gta');
            if(guessLabel) guessLabel.textContent = `Guess Age: ${data.celebrity_name}`;
            if(guessInput) { guessInput.placeholder = 'Age (0-120)'; guessInput.min='0'; guessInput.max='120'; guessInput.disabled = false; guessInput.value='';}
            if(submitGuessButton) submitGuessButton.disabled = false;
            if(statusMessage) statusMessage.textContent = 'Enter guess!'; showArea('guessing-area');
            console.log('GTA Guessing area shown.');
        });
        socket.on('gta_wait_for_guesses', (data) => {
            console.log('GTA Wait'); if(statusMessage) statusMessage.textContent = `Waiting (${data.waiting_on} left)...`;
            if(guessInput) guessInput.disabled = true; if(submitGuessButton) submitGuessButton.disabled = true;
        });

        // --- GTY Listeners ---
        socket.on('gty_player_prompt', (data) => {
             console.log('--- Event: gty_player_prompt received ---', data); currentClientRoundType = 'gty'; configureInputArea('gty');
             if(guessLabel) guessLabel.textContent = `Q: ${data.question}`;
             if(guessInput) { guessInput.placeholder = 'Year (YYYY)'; guessInput.min=''; guessInput.max=''; guessInput.disabled = false; guessInput.value='';}
             if(submitGuessButton) submitGuessButton.disabled = false;
             if(statusMessage) statusMessage.textContent = 'Enter guess!'; showArea('guessing-area');
             console.log('GTY Guessing area shown.');
        });
        socket.on('gty_wait_for_guesses', (data) => {
             console.log('GTY Wait'); if(statusMessage) statusMessage.textContent = `Waiting (${data.waiting_on} left)...`;
             if(guessInput) guessInput.disabled = true; if(submitGuessButton) submitGuessButton.disabled = true;
        });

        // --- WDDI Listeners ---
        socket.on('wddi_player_prompt', (data) => {
            // data should contain { question: "...", shuffled_options: ["Opt A", "Opt B", ...] }
            console.log('--- Event: wddi_player_prompt received ---', data);
            if (!data || !data.shuffled_options || data.shuffled_options.length !== 6) {
                console.error("WDDI prompt received invalid data:", data);
                if(statusMessage) statusMessage.textContent = "Error loading question.";
                return;
            }

            currentClientRoundType = 'wddi';
            configureInputArea('wddi'); // Hides text input, shows button area

            if(guessLabel) {
                // Use the actual question text received
                guessLabel.textContent = data.question || "Which one doesn't belong?";
            }
            if(statusMessage) {
                statusMessage.textContent = 'Choose an option (1-6):';
            }

            if(wddiOptionsArea) {
                wddiOptionsArea.innerHTML = ''; // Clear any old buttons first
                console.log("   Creating WDDI option buttons...");

                // Loop through the SHUFFLED options received from the server
                data.shuffled_options.forEach((optionText, index) => {
                    const button = document.createElement('button');
                    // Label button 1-6, and maybe include the text? Or keep it simple?
                    // Let's include text for clarity on the small screen.
                    button.textContent = optionText;
                    button.dataset.optionText = optionText; // Store the actual text to send back
                    button.addEventListener('click', handleWddiChoice);
                    wddiOptionsArea.appendChild(button);
                    console.log(`    -> Created button ${index + 1} for option: ${optionText}`);
                });
            } else {
                console.error("WDDI options area (#wddi-options-area) not found!");
                if(statusMessage) statusMessage.textContent = "UI Error.";
            }
            showArea('guessing-area'); // Make sure the guessing area is visible
            console.log('WDDI Guessing area prepared and shown.');
        });

        // --- Order Up! Listeners ---
        socket.on('ou_player_prompt', (data) => {
            // data should contain { question: "...", items_to_order: ["Item A", "Item B", ...] }
            console.log('DEBUG CLIENT: --- Event: ou_player_prompt received BY CLIENT ---', data);
            if (!data || !data.items_to_order || !Array.isArray(data.items_to_order)) {
                console.error("DEBUG CLIENT: OU prompt received invalid data:", data);
                if(statusMessage) statusMessage.textContent = "Error loading question items.";
                return;
            }

            currentClientRoundType = 'ou';
            configureInputArea('ou'); // Shows ouItemsListContainer and submitOrderButton

            if(guessLabel) {
                guessLabel.textContent = data.question || "Arrange these items in order:";
            }
            if(statusMessage) {
                statusMessage.textContent = 'Drag items to order them, then submit.';
            }

            if(ouItemsList) {
                ouItemsList.innerHTML = ''; // Clear any old items

                data.items_to_order.forEach(itemText => {
                    const listItem = document.createElement('li');
                    listItem.textContent = itemText;
                    // Optional: listItem.dataset.originalText = itemText; // If needed later
                    ouItemsList.appendChild(listItem);
                });

                // Initialize SortableJS
                if (sortableInstance) { // Destroy previous instance if any
                    sortableInstance.destroy();
                }
                sortableInstance = new Sortable(ouItemsList, {
                    animation: 150, // Animation speed
                    ghostClass: 'sortable-ghost',  // Class for the ghost item
                    chosenClass: 'sortable-chosen', // Class for the chosen item
                    // You can add more options here if needed
                });
                console.log("   SortableJS initialized for Order Up list.");
                if(submitOrderButton) submitOrderButton.disabled = false; // Enable submit button now
            } else {
                console.error("Order Up items list (#ou-items-list) not found!");
                if(statusMessage) statusMessage.textContent = "UI Error (List).";
            }
            showArea('guessing-area'); // Ensure the main guessing area is visible
            console.log('Order Up! Guessing area prepared and shown.');
        });

        // --- Quick Pairs Listeners ---
        socket.on('qp_player_prompt', (data) => {
            // data: { category_prompt: "...", list_a: ["A1","A2","A3"], list_b: ["B1","B2","B3"], num_pairs_to_make: 3 }
            console.log('--- Event: qp_player_prompt received BY CLIENT ---', data);

            if (!data || !data.list_a || !data.list_b || !data.category_prompt || data.num_pairs_to_make === undefined) {
                console.error("DEBUG CLIENT: QP prompt received invalid data:", data);
                if(statusMessage) statusMessage.textContent = "Error loading pairing game.";
                return;
            }

            currentClientRoundType = 'qp';
            // QP_NUM_PAIRS_TO_MAKE = data.num_pairs_to_make; // Update if server sends a different number
            configureInputArea('qp'); // Shows qpPairingArea, submitPairsButton (disabled)

            if(guessLabel) {
                guessLabel.textContent = data.category_prompt;
            }
            if(statusMessage) {
                statusMessage.textContent = `Match ${data.num_pairs_to_make} pairs! Select one from each list.`;
            }

            qpSelectedFromListA = null; // Reset any previous selection from list A
            qpFormedPairs = [];         // Reset formed pairs for the new turn
            updateFormedPairsDisplay(); // Clear the display of formed pairs

            // Populate List A
            qpListA.innerHTML = ''; // Clear previous items
            data.list_a.forEach(itemTextA => {
                const li = document.createElement('li');
                li.textContent = itemTextA;
                li.dataset.listId = 'A'; // Identify which list this item belongs to
                li.addEventListener('click', handleQuickPairItemClick);
                qpListA.appendChild(li);
            });

            // Populate List B
            qpListB.innerHTML = ''; // Clear previous items
            data.list_b.forEach(itemTextB => {
                const li = document.createElement('li');
                li.textContent = itemTextB;
                li.dataset.listId = 'B'; // Identify which list this item belongs to
                li.addEventListener('click', handleQuickPairItemClick);
                qpListB.appendChild(li);
            });
            
            qpStartTime = new Date().getTime(); // Record start time for this turn's pairing activity
            if(submitPairsButton) submitPairsButton.disabled = true; // Keep disabled until all pairs are made

            showArea('guessing-area');
            console.log('Quick Pairs guessing area prepared and shown.');
        });

        // --- True or False Listeners ---
        socket.on('true_or_false_player_prompt', (data) => {
            console.log('--- Event: true_or_false_player_prompt received ---', data);
            currentClientRoundType = 'true_or_false';
            
            // STEP 1: Show the main parent container for all guess inputs.
            showArea('guessing-area');
            
            // STEP 2: Configure the inputs INSIDE that container for this specific round.
            configureInputArea('true_or_false');

            // STEP 3: Update the labels and button states.
            if(guessLabel) guessLabel.textContent = "Is this statement True or False?";
            if(statusMessage) statusMessage.textContent = data.statement;

            trueButton.disabled = false;
            falseButton.disabled = false;
        });

        // --- The Top Three Listeners ---
        socket.on('top_three_player_prompt', (data) => {
            // data: { question: "...", options: [...] }
            console.log('--- Event: top_three_player_prompt received ---', data);
            currentClientRoundType = 'the_top_three';
            
            showArea('guessing-area');
            configureInputArea('the_top_three');

            if (guessLabel) guessLabel.textContent = data.question;
            if (statusMessage) statusMessage.textContent = 'Select three options from the list below.';
            
            // Dynamically create the list of tappable options
            topThreeOptionsList.innerHTML = ''; // Clear previous options
            data.options.forEach(optionText => {
                const li = document.createElement('li');
                li.textContent = optionText;
                li.addEventListener('click', handleTopThreeChoice);
                topThreeOptionsList.appendChild(li);
            });
        });

        // --- Common Listeners ---
        socket.on('results_on_main_screen', () => {
            console.log('Results on main screen notice.'); if(statusMessage) statusMessage.textContent = 'Check main screen!';
            configureInputArea(null); showArea('guessing-area');
        });
        socket.on('overall_game_over_player', () => {
            console.log('Overall game over notice.'); if(statusMessage) statusMessage.textContent = 'GAME OVER! Check main screen.';
            configureInputArea(null); currentClientRoundType = null; showArea('guessing-area');
        });

        // --- User Interaction Handlers ---
        function handleWddiChoice(event) {
            // Get the actual text stored in the data attribute
            const chosenOptionText = event.target.dataset.optionText;

            if (!chosenOptionText) {
                console.error("Clicked WDDI button missing option text!", event.target);
                if (statusMessage) statusMessage.textContent = "Selection Error!";
                return;
            }

            console.log(`WDDI Choice clicked: Text='${chosenOptionText}'`);
            // Emit the event the server expects, sending the text
            socket.emit('submit_wddi_guess', { 'guess_text': chosenOptionText });
            console.log("   -> Emitted 'submit_wddi_guess' with text.");

            // Disable all buttons in the area after choosing one
            if(wddiOptionsArea) {
                Array.from(wddiOptionsArea.children).forEach(btn => {
                    btn.disabled = true;
                    // Optional: highlight the selected button?
                    if (btn === event.target) {
                        btn.style.backgroundColor = '#2ecc71'; // Example: Green highlight
                    }
                });
                console.log("   -> Disabled WDDI option buttons.");
            }

            if (statusMessage) {
                statusMessage.textContent = 'Guess submitted! Waiting...';
            }
        }

        function handleSubmitOrderUp() {
            if (!sortableInstance || !ouItemsList) {
                console.error("Cannot submit order: SortableJS instance or list not found.");
                if(statusMessage) statusMessage.textContent = "Error submitting.";
                return;
            }

            // Get the current order of items from the DOM (SortableJS modifies the DOM directly)
            const orderedItems = [];
            const listItems = ouItemsList.querySelectorAll('li');
            listItems.forEach(li => {
                orderedItems.push(li.textContent); // Or from li.dataset.originalText if you used that
            });

            console.log(`Order Up! Submitting order:`, orderedItems);
            socket.emit('submit_ou_list', { 'ordered_list': orderedItems });
            // Event name 'submit_ou_list' matches backend

            // Disable UI after submission
            if (sortableInstance) {
                sortableInstance.option('disabled', true); // Disable further dragging
            }
            if (submitOrderButton) {
                submitOrderButton.disabled = true;
            }
            if (statusMessage) {
                statusMessage.textContent = 'Order submitted! Waiting...';
            }
        }

        function handleQuickPairItemClick(event) {
            const clickedItem = event.target;
            const clickedItemText = clickedItem.textContent;
            const listId = clickedItem.dataset.listId;

            if (clickedItem.classList.contains('qp-paired')) {
                console.log("Clicked on an already paired item. Ignoring.");
                return; // Ignore clicks on already paired items
            }

            if (listId === 'A') {
                // If an item in List A is already selected, deselect it
                if (qpSelectedFromListA && qpSelectedFromListA.element) {
                    qpSelectedFromListA.element.classList.remove('qp-selected');
                }
                // If clicking the same selected item from List A again, deselect it
                if (qpSelectedFromListA && qpSelectedFromListA.text === clickedItemText) {
                    qpSelectedFromListA = null;
                    console.log(`Deselected from List A: ${clickedItemText}`);
                } else {
                    // Select the new item from List A
                    clickedItem.classList.add('qp-selected');
                    qpSelectedFromListA = { text: clickedItemText, element: clickedItem };
                    console.log(`Selected from List A: ${clickedItemText}`);
                }
                // If an item from List B was also selected, try to form a pair (shouldn't happen with A->B flow)
                // This check is mostly if we allowed B then A selection. For A then B, this is less critical.
                // if (qpSelectedFromListB) tryToFormPair(); 

            } else if (listId === 'B') {
                if (qpSelectedFromListA) { // An item from List A must be selected first to form a pair
                    // Attempt to form a pair
                    const pair = [qpSelectedFromListA.text, clickedItemText];
                    console.log(`Attempting to form pair: ${pair[0]} with ${pair[1]}`);

                    // Add pair to our list
                    qpFormedPairs.push(pair);
                    updateFormedPairsDisplay(); // Update the visual display of formed pairs

                    // Mark both items as paired and deselect from List A
                    qpSelectedFromListA.element.classList.remove('qp-selected');
                    qpSelectedFromListA.element.classList.add('qp-paired');
                    clickedItem.classList.add('qp-paired');
                    
                    console.log(`Paired: ${qpSelectedFromListA.text} - ${clickedItemText}`);
                    qpSelectedFromListA = null; // Reset List A selection

                    // Check if all pairs are made
                    // Assuming QP_NUM_PAIRS_TO_MAKE is defined globally (e.g., 3) or passed from server
                    if (qpFormedPairs.length === QP_NUM_PAIRS_TO_MAKE) {
                        console.log("All pairs made!");
                        if(statusMessage) statusMessage.textContent = "All pairs made! Submit or review.";
                        if(submitPairsButton) submitPairsButton.disabled = false; // Enable submit button
                        // Optionally auto-submit here, or wait for button press
                        // handleSubmitQuickPairs(); // Example: auto-submit
                    }
                } else {
                    console.log("Select an item from List A first!");
                    if(statusMessage) statusMessage.textContent = "Select an item from List A first!";
                    // Optionally, briefly highlight the item in List B then unhighlight
                }
            }
        }

        function updateFormedPairsDisplay() {
            if (!qpFormedPairsDisplay) return;
            qpFormedPairsDisplay.innerHTML = ''; // Clear previous
            if (qpFormedPairs.length > 0) {
                qpFormedPairsDisplay.innerHTML = 'Your Pairs: ';
                qpFormedPairs.forEach(pair => {
                    const pairSpan = document.createElement('span');
                    pairSpan.classList.add('formed-pair');
                    pairSpan.textContent = `${pair[0]} - ${pair[1]}`;
                    qpFormedPairsDisplay.appendChild(pairSpan);
                });
            }
        }

        function handleSubmitQuickPairs() {
            if (qpFormedPairs.length !== QP_NUM_PAIRS_TO_MAKE) {
                console.warn("Attempted to submit Quick Pairs before all pairs were made.");
                if(statusMessage) statusMessage.textContent = `You need to make ${QP_NUM_PAIRS_TO_MAKE} pairs!`;
                return;
            }

            const timeTakenMs = new Date().getTime() - qpStartTime;
            console.log(`Quick Pairs: Submitting pairs:`, qpFormedPairs, `Time: ${timeTakenMs}ms`);

            socket.emit('submit_qp_pairs', {
                'player_pairs': qpFormedPairs,
                'time_ms': timeTakenMs
            });

            // PASTE THE CODE HERE. It now correctly runs after the emit.
            // Disable UI after submission
            if(submitPairsButton) submitPairsButton.disabled = true;
            // Disable further clicks on list items
            [...qpListA.querySelectorAll('li'), ...qpListB.querySelectorAll('li')].forEach(li => {
                li.removeEventListener('click', handleQuickPairItemClick); // Remove listener
                if (!li.classList.contains('qp-paired')) { // Dim items not already paired (e.g. if auto-submit was off)
                    li.style.opacity = '0.5';
                    li.style.cursor = 'not-allowed';
                }
            });

            if (statusMessage) {
                statusMessage.textContent = 'Pairs submitted! Waiting...';
            }
            console.log("Quick Pairs submission sent. UI disabled.");
        }
        
        
        function handleTrueFalseChoice(event) {
            const chosenAnswer = event.target.dataset.answer === 'true'; // Convert string to boolean
            console.log(`True/False choice: ${chosenAnswer}`);
            socket.emit('submit_true_or_false_guess', { 'guess': chosenAnswer });

            // Disable both buttons
            trueButton.disabled = true;
            falseButton.disabled = true;
            statusMessage.textContent = 'Guess submitted! Waiting...';
        }

        function handleTapThePicChoice(event) {
            const chosenNumber = event.target.dataset.answer; // This will be a string "1", "2", etc.
            console.log(`Tap The Pic choice: ${chosenNumber}`);
            socket.emit('submit_ttp_guess', { 'guess': parseInt(chosenNumber, 10) }); // Send it as a number

            // Disable all keypad buttons after choosing one
            const buttons = tapThePicArea.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = true;
                // Highlight the selected one
                if (btn === event.target) {
                    btn.style.backgroundColor = 'var(--color-success)';
                }
            });
            statusMessage.textContent = 'Guess submitted! Waiting...';
        }

        function handleTopThreeChoice(event) {
            const selectedItem = event.currentTarget; // Use currentTarget to get the <li>
            const selectedCount = topThreeOptionsList.querySelectorAll('li.selected').length;

            // Toggle the 'selected' class
            // But prevent selecting a 4th item
            if (!selectedItem.classList.contains('selected') && selectedCount >= 3) {
                console.log("Cannot select more than 3 items.");
                // Optional: give player feedback like a screen shake or message
                return;
            }
            selectedItem.classList.toggle('selected');

            // Check again how many are selected now
            const newSelectedCount = topThreeOptionsList.querySelectorAll('li.selected').length;
            
            // Enable/disable the submit button based on the count
            submitTopThreeButton.disabled = (newSelectedCount !== 3);
        }

        function handleSubmitTopThree() {
            const selectedItems = topThreeOptionsList.querySelectorAll('li.selected');
            const selectedAnswers = [];
            selectedItems.forEach(item => {
                selectedAnswers.push(item.textContent);
            });

            console.log("Submitting Top Three guess:", selectedAnswers);
            socket.emit('submit_top_three_guess', { 'guess': selectedAnswers });

            // Disable all options and the submit button
            const allOptions = topThreeOptionsList.querySelectorAll('li');
            allOptions.forEach(item => {
                item.removeEventListener('click', handleTopThreeChoice);
                if (!item.classList.contains('selected')) {
                    item.style.opacity = '0.5';
                }
            });
            submitTopThreeButton.disabled = true;
            statusMessage.textContent = 'Guess submitted! Waiting...';
        }

        // Add this new socket listener with the others
        socket.on('tap_the_pic_player_prompt', (data) => {
            // data: { question: "...", num_options: 4 }
            console.log('--- Event: tap_the_pic_player_prompt received ---', data);
            currentClientRoundType = 'tap_the_pic';
            
            showArea('guessing-area');
            configureInputArea('tap_the_pic');

            if (guessLabel) guessLabel.textContent = data.question;
            if (statusMessage) statusMessage.textContent = 'Choose the correct number!';
            
            // Dynamically create the keypad buttons
            tapThePicArea.innerHTML = ''; // Clear previous buttons
            for (let i = 1; i <= data.num_options; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.dataset.answer = i;
                button.addEventListener('click', handleTapThePicChoice);
                tapThePicArea.appendChild(button);
            }
        });

        // --- Attach Listeners and Get Elements After DOM Loaded ---
        document.addEventListener('DOMContentLoaded', (event) => {
             console.log("Player DOM loaded.");
             // Get element references now
             nameEntryArea = document.getElementById('name-entry-area');
             nameInput = document.getElementById('nameInput');
             joinButton = document.getElementById('joinButton');
             guessingArea = document.getElementById('guessing-area');
             // gameInfoDiv = document.getElementById('game-info'); // Removed for now
             // gameRoundNumSpan = document.getElementById('game-round-num');
             // gameRoundTotalSpan = document.getElementById('game-round-total');
             guessLabel = document.getElementById('guess-label');
             guessInput = document.getElementById('guessInput');
             submitGuessButton = document.getElementById('submitGuessButton');
             statusMessage = document.getElementById('status-message');
             wddiOptionsArea = document.getElementById('wddi-options-area');
             guessInput = document.getElementById('guessInput');
             submitGuessButton = document.getElementById('submitGuessButton');
             statusMessage = document.getElementById('status-message');
             wddiOptionsArea = document.getElementById('wddi-options-area');
             ouItemsListContainer = document.getElementById('ou-items-list-container');
             ouItemsList = document.getElementById('ou-items-list');
             submitOrderButton = document.getElementById('submitOrderButton');
             qpPairingArea = document.getElementById('qp-pairing-area');
             qpListA = document.getElementById('qp-list-a');
             qpListB = document.getElementById('qp-list-b');
             qpFormedPairsDisplay = document.getElementById('qp-formed-pairs-display');
             submitPairsButton = document.getElementById('submitPairsButton');
             trueOrFalseArea = document.getElementById('true-or-false-area');
             trueButton = document.getElementById('true-button');
             falseButton = document.getElementById('false-button');
             tapThePicArea = document.getElementById('tap-the-pic-area');
             topThreeArea = document.getElementById('top-three-area');
             topThreeOptionsList = document.getElementById('top-three-options-list');
             submitTopThreeButton = document.getElementById('submitTopThreeButton');

             if (!nameEntryArea || !guessingArea || !statusMessage || !nameInput || !joinButton || !guessInput || !submitGuessButton || !wddiOptionsArea || !ouItemsListContainer || !ouItemsList || !submitOrderButton || !qpPairingArea || !qpListA || !qpListB || !submitPairsButton || !qpFormedPairsDisplay || !trueOrFalseArea || !trueButton || !falseButton  || !tapThePicArea || !topThreeArea || !topThreeOptionsList || !submitTopThreeButton) {
                 console.error("CRITICAL ERROR: One or more essential player controller elements not found!");
                 if (statusMessage) statusMessage.textContent = "Page Load Error!";
                 return;
             }

             // Attach join button listener
             if(joinButton) {
                 console.log("Attempting to attach JOIN listener...");
                 joinButton.addEventListener('click', () => {
                     console.log(">>> JOIN BUTTON CLICKED <<<");
                     const name = nameInput.value.trim();
                     console.log(`DEBUG: Name entered: '${name}'`);
                     if (name) {
                         console.log(`Registering as player: ${name}`);
                         socket.emit('register_player', { name: name });
                         console.log("DEBUG: register_player event emitted.");
                         showArea('guessing-area'); // Show the guessing area div
                         console.log("DEBUG: Called showArea('guessing-area').");
                         if (statusMessage) statusMessage.textContent = 'Waiting for the game to start...';
                         configureInputArea(null); // Hide specific inputs within guessing area
                     } else {
                         console.log("DEBUG: Name was empty.");
                         if (statusMessage) statusMessage.textContent = 'Please enter a name!';
                     }
                     console.log(">>> JOIN BUTTON HANDLER FINISHED <<<");
                 });
                 console.log("DEBUG: Listener ATTACHED to joinButton.");
             } else { console.error("ERROR: joinButton reference was null."); }

             // Attach name input enter key listener
             if(nameInput) { nameInput.addEventListener('keypress', function (e) { if (e.key === 'Enter' && joinButton && !joinButton.disabled) { joinButton.click(); }}); }

             // Attach submit guess button listener
             if(submitGuessButton) {
                 console.log("Attempting to attach SUBMIT GUESS listener...");
                 submitGuessButton.addEventListener('click', () => {
                     console.log(">>> SUBMIT GUESS BUTTON CLICKED <<<");
                     const guess = guessInput.value;
                     console.log(`DEBUG: Guess value: '${guess}', Current Round Type: ${currentClientRoundType}`);
                     if (currentClientRoundType === 'gta') {
                          console.log("DEBUG: Processing as GTA guess...");
                          if (guess !== '' && !isNaN(guess) && parseInt(guess) >= 0 && parseInt(guess) <= 120) { socket.emit('submit_gta_guess', { guess: parseInt(guess) }); console.log("DEBUG: submit_gta_guess emitted."); }
                          else { console.log("DEBUG: Invalid GTA guess."); if (statusMessage) statusMessage.textContent = 'Invalid age (0-120).'; }
                     } else if (currentClientRoundType === 'gty') {
                          console.log("DEBUG: Processing as GTY guess...");
                          if (guess !== '' && !isNaN(guess)) { socket.emit('submit_gty_guess', { guess: parseInt(guess) }); console.log("DEBUG: submit_gty_guess emitted."); }
                          else { console.log("DEBUG: Invalid GTY guess."); if (statusMessage) statusMessage.textContent = 'Invalid year.'; }
                     } else { console.log("DEBUG: No active round type known or submit clicked inappropriately."); if (statusMessage) statusMessage.textContent = "Not time to guess!"; }
                     console.log(">>> SUBMIT GUESS HANDLER FINISHED <<<");
                 });
                 console.log("DEBUG: Listener ATTACHED to submitGuessButton.");
             } else { console.error("ERROR: submitGuessButton reference was null."); }

             // Attach guess input enter key listener
             if(guessInput) { guessInput.addEventListener('keypress', function (e) { if (e.key === 'Enter' && submitGuessButton && !submitGuessButton.disabled) { submitGuessButton.click(); }}); }
            
             if(submitOrderButton) {
                submitOrderButton.addEventListener('click', handleSubmitOrderUp);
             }

             if(submitPairsButton) {
                submitPairsButton.addEventListener('click', handleSubmitQuickPairs);
             }

             if(trueButton && falseButton) {
                trueButton.addEventListener('click', handleTrueFalseChoice);
                falseButton.addEventListener('click', handleTrueFalseChoice);
             }

             if (submitTopThreeButton) {
                submitTopThreeButton.addEventListener('click', handleSubmitTopThree);
             }

             console.log("Player initial listeners setup complete.");
             showArea('name-entry-area'); // Ensure starting view

        }); // End DOMContentLoaded

    </script>
</body>
</html>